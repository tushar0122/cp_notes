HashMap
    => var mp = new HashMap<E>();

Initialization 
    => var mp = new HashMap<>();
    => var mp = new HashMap<>(otherMap);

Compare 
    => mp1.equals(mp2) => match key and values 

Access, Insert, Remove
    => mp.get() to access value element
    => mp.put() to add key value element
    => mp.remove(key) to remove key 

Access Time Complexity
    => O(1)

Insert Time Complexity 
    => O(logN) 

Remove Time Complexity
    => O(logN)

Iterating 
    => pq.iterator()
    while(iterator.hasNext()){
        iterator.next()
    }

Access
    => mp.keySet()

map.computeIfPresent("apple", (key, val) -> val + 5);

lambda expression 
    => can't use variables that changes afterwards

    removing an element but we don't know if it is part of old one are not
    k element 
    now let say i am removing an element an add

nv was there in previous sum
    => 
nv was not there in previous sum 
    => 
pvf > nvf no chance 
pvf = nvf & pvf > nvf no chance 
